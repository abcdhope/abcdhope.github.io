<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通讯即时系统</title>
      <link href="/8862.html"/>
      <url>/8862.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础server构建"><a href="#基础server构建" class="headerlink" title="基础server构建"></a>基础server构建</h1><p>本节主要是建立链接。</p><p>通过<code>net.listen</code>来监听端口，通过<code>Listener.Accept()</code>来接收客户端的请求，然后利用go来进行处理多个请求链接。</p><pre class="language-go" data-language="go"><code class="language-go">type Server struct &#123;Ip   stringPort int&#125;&#x2F;&#x2F;初始化func NewServer(ip string, port int) *Server &#123;return &amp;Server&#123;Ip:   ip,Port: port,&#125;&#125;func (s *Server) Handler(conn net.Conn) &#123;fmt.Println(&quot;链接建立成功&quot;)&#125;&#x2F;&#x2F;启动服务器的接口func (s *Server) Start() &#123;&#x2F;&#x2F;端口监听Listener, err :&#x3D; net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, s.Ip, s.Port))if err !&#x3D; nil &#123;fmt.Println(&quot;net.Listen err:&quot;, err)return&#125;&#x2F;&#x2F;关闭端口defer Listener.Close()for &#123;&#x2F;&#x2F;接收客户端的连接conn, err :&#x3D; Listener.Accept()if err !&#x3D; nil &#123;fmt.Println(&quot;Listener err:&quot;, err)return&#125;&#x2F;&#x2F; do handlergo s.Handler(conn)&#125;&#125;</code></pre><p>最后开启端口：</p><pre class="language-go" data-language="go"><code class="language-go">func main() &#123;server :&#x3D; NewServer(&quot;127.0.0.1&quot;, 8888)server.Start() &#x2F;&#x2F;开启端口&#125;</code></pre><p>当客户端发送请求链接时，服务器输出<code>链接建立成功</code>.</p><h1 id="用户上线功能"><a href="#用户上线功能" class="headerlink" title="用户上线功能"></a>用户上线功能</h1><p>在上一节中，建立了服务器与客户端的连接。在这一节中，添加用户并且服务器给客户端返回消息。</p><p>首先创建用户结构，用于存放用户名字、用户地址、用户通道、用户对应的链接。</p><pre class="language-go" data-language="go"><code class="language-go">type User struct &#123;Name stringAddr stringC    chan string &#x2F;&#x2F;用户通道，用于将消息传给用户conn net.Conn    &#x2F;&#x2F;用户链接&#125;</code></pre><p>C通道用于广播消息给所有客户端，而conn链接用于对该客户端的一些操作。</p><p>然后进行初始化：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;创建一个用户的APIfunc NewUser(conn net.Conn, server *Server) *User &#123;userAddr :&#x3D; conn.RemoteAddr().String() &#x2F;&#x2F;客户端的请求地址user :&#x3D; &amp;User&#123;Name:   userAddr,Addr:   userAddr,C:      make(chan string),conn:   conn,&#125;&#x2F;&#x2F;启动监听当前user channel消息的goroutinego user.ListenMessage()return user&#125;</code></pre><p>ListenMessage用于一直监听当前通道的消息，并将消息发送给给客户端:</p><pre class="language-go" data-language="go"><code class="language-go">func (u *User) ListenMessage() &#123;for &#123;msg :&#x3D; &lt;-u.Cu.conn.Write([]byte(msg + &quot;\n&quot;))&#125;&#125;</code></pre><p>在服务器的结构上，添加用户列表功能和消息功能，用户列表用于存放当前存在的用户，而消息功能用于将消息传递给客户端：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;创建用户列表OnlineMap map[string]*UsermapLock   sync.RWMutex&#x2F;&#x2F;消息广播的channelMessage chan string</code></pre><p>mapLock代表锁，用于当前用户的操作。</p><p>然后在handler里添加用户上线功能，并将用户添加至列表中，用于是并发运行该函数，因此加上锁来防止其他用户一起上线：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中s.mapLock.Lock() &#x2F;&#x2F;上锁s.OnlineMap[user.Name] &#x3D; users.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息s.BroadCase(user, &quot;已上线&quot;)&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#125;</code></pre><p>BroadCase用于广播消息，将消息通过用户通道来传递给用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;广播消息func (s *Server) BroadCase(user *User, msg string) &#123;sendMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + msgs.Message &lt;- sendMsg&#125;</code></pre><p>且在start方法中开启一个go程来持续监听消息通道，并将通道的消息传递给用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;监听消息广播通道，一旦有消息则将消息广播给所有用户func (s *Server) ListenMessage() &#123;for &#123;msg :&#x3D; &lt;-s.Message &#x2F;&#x2F; 无消息则阻塞s.mapLock.Lock()   &#x2F;&#x2F;上锁for _, user :&#x3D; range s.OnlineMap &#123;user.C &lt;- msg &#x2F;&#x2F;将消息传给所有用户&#125;s.mapLock.Unlock()&#125;&#125;</code></pre><h1 id="用户消息广播机制"><a href="#用户消息广播机制" class="headerlink" title="用户消息广播机制"></a>用户消息广播机制</h1><p>在上一节中已经实现了通过通道来将消息传递给每个客户端，本节主要是服务器读取客户端发来的消息并将消息进行广播，核心方法还是BroadCase：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中s.mapLock.Lock() &#x2F;&#x2F;上锁s.OnlineMap[user.Name] &#x3D; users.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息s.BroadCase(user, &quot;已上线&quot;)&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#x2F;&#x2F;接收客户端发送的消息并广播给所有用户go func() &#123;buf :&#x3D; make([]byte, 4096)for &#123;n, err :&#x3D; conn.Read(buf)if n &#x3D;&#x3D; 0 &#123;s.BroadCase(user, &quot;已下线&quot;)return&#125;if err !&#x3D; nil &amp;&amp; err !&#x3D; io.EOF &#123;fmt.Println(&quot;Conn Read err:&quot;, err)&#125;msg :&#x3D; string(buf[:n-1])s.BroadCase(user, msg)&#125;&#125;()&#125;</code></pre><p>在handler方法中增加一个go程来接收用户发来的消息，利用go程可以保持客户端与服务器互通。在go程中首先创建一个字节数组用于保存链接中的信息，并返回信息的长度，如果长度为0则表示用户断开了连接，因此给其他用户广播该用户已下线并结束这一个go程，如果长度不为0则将消息广播给所有用户，n-1表示信息里面最后一位是换行字符<code>\n</code>。</p><h1 id="用户业务层封装"><a href="#用户业务层封装" class="headerlink" title="用户业务层封装"></a>用户业务层封装</h1><p>在上一节中，在handler中定义了用户上线和下线以及将用户发送的消息进行广播，为了方便后续增加功能，现将这些功能进行封装给用户。</p><p>首先为user结构添加server对象：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;新增Server关联server *Server</code></pre><p>增加的意义在于user的方法可以调用server的方法，例如消息传递功能BroadCase。</p><p>定义上线功能，功能里包含用户列表增加新用户、广播用户上线：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户上线func (u *User) Online() &#123;&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中u.server.mapLock.Lock() &#x2F;&#x2F;上锁u.server.OnlineMap[u.Name] &#x3D; uu.server.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息u.server.BroadCase(u, &quot;已上线&quot;)&#125;</code></pre><p>同理定义下线功能：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户下线func (u *User) Offline() &#123;u.server.mapLock.Lock() &#x2F;&#x2F;上锁delete(u.server.OnlineMap, u.Name)u.server.mapLock.Unlock()u.server.BroadCase(u, &quot;已下线&quot;)&#125;</code></pre><p>定义发送消息功能，将客户端发送给服务器的消息进行封装：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户处理消息的业务func (u *User) DoMessage(msg string) &#123;u.server.BroadCase(u, msg)&#125;</code></pre><p>最后handler改为：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn, s)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中user.Online()&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#x2F;&#x2F;接收客户端发送的消息并广播给所有用户go func() &#123;buf :&#x3D; make([]byte, 4096)for &#123;&#x2F;&#x2F;读取客户端传来的数据n, err :&#x3D; conn.Read(buf)if n &#x3D;&#x3D; 0 &#123;user.Offline() &#x2F;&#x2F;下线return&#125;if err !&#x3D; nil &amp;&amp; err !&#x3D; io.EOF &#123;fmt.Println(&quot;Conn Read err:&quot;, err)&#125;msg :&#x3D; string(buf[:n-1])user.DoMessage(msg) &#x2F;&#x2F;用户针对msg进行消息处理&#125;&#125;()&#125;</code></pre><h1 id="在线用户查询"><a href="#在线用户查询" class="headerlink" title="在线用户查询"></a>在线用户查询</h1><p>在上一节中定义消息处理函数DoMessage，现在在方法里增加用户查询功能，当用户输入<code>who</code>时，服务器返回用户在线列表：</p><pre class="language-go" data-language="go"><code class="language-go">func (u *User) DoMessage(msg string) &#123;if msg &#x3D;&#x3D; &quot;who&quot; &#123;&#x2F;&#x2F;查询当前在线用户都有哪些fmt.Println(&quot;进入该代码块&quot;)u.server.mapLock.Lock()for _, user :&#x3D; range u.server.OnlineMap &#123;onlineMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + &quot;在线...\n&quot;u.SendMsg(onlineMsg)&#125;u.server.mapLock.Unlock()&#125; else &#123;u.server.BroadCase(u, msg)&#125;&#125;</code></pre><p>当输入<code>who</code>时，遍历列表中的用户并将这些用户发送给请求的客户端，SendMsg方法用于将信息发送给当前用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;给当前User对应的客户端发送消息func (u *User) SendMsg(msg string) &#123;u.conn.Write([]byte(msg))&#125;</code></pre><p>由于消息里存在换行符等制表符，因此调用strings.TrimSpace将主要字符的左右两端的制表符和空格进行去除：</p><pre class="language-go" data-language="go"><code class="language-go">strings.TrimSpace(s string)</code></pre><h1 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h1><p>在上一节中，定义了查询在线用户功能。在本节中通过增加修改用户名的功能来为客户端发送的修改用户名请求进行处理，消息格式定义为：<code>rename|张三</code>：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户处理消息的业务func (u *User) DoMessage(msg string) &#123;if msg &#x3D;&#x3D; &quot;who&quot; &#123;&#x2F;&#x2F;查询当前在线用户都有哪些&#x2F;&#x2F; fmt.Println(&quot;进入该代码块&quot;)u.server.mapLock.Lock()for _, user :&#x3D; range u.server.OnlineMap &#123;onlineMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + &quot;在线...\n&quot;u.SendMsg(onlineMsg)&#125;u.server.mapLock.Unlock()&#125; else if len(msg) &gt; 7 &amp;&amp; msg[:7] &#x3D;&#x3D; &quot;rename|&quot; &#123;&#x2F;&#x2F;消息格式为：&quot;rename|张三&quot;&#x2F;&#x2F;将名字进行分离出来newName :&#x3D; strings.Split(msg, &quot;|&quot;)[1]if _, ok :&#x3D; u.server.OnlineMap[newName]; ok &#123;u.SendMsg(&quot;当前用户名已被注册\n&quot;)&#125; else &#123;u.server.mapLock.Lock()&#x2F;&#x2F;删除旧的用户delete(u.server.OnlineMap, u.Name)u.server.OnlineMap[newName] &#x3D; u &#x2F;&#x2F;将新的名字添加至用户列表中u.server.mapLock.Unlock()u.Name &#x3D; newNameu.SendMsg(&quot;您已经更新用户名：&quot; + u.Name + &quot;\n&quot;)&#125;&#125; else &#123;u.server.BroadCase(u, msg)&#125;&#125;</code></pre><p>通过strings.Split将消息中的请求名字给提取出来，并且判断该名字是否已被注册，若被注册就给该客户端发消息：<code>当前用户名已被注册\n</code>，否则先删除列表中旧的用户，更新新的用户名，更新完成后给该客户端发送更新后的信息。</p><h1 id="超时强踢功能"><a href="#超时强踢功能" class="headerlink" title="超时强踢功能"></a>超时强踢功能</h1><p>在上一节中，对用户名进行了修改。在本节中加入超时强踢功能，当客户端在一定时间内没有发送消息就默认掉线，服务器就关闭对该客户端的链接：</p><p>添加一个bool通道，用于判断该用户是否活跃：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户活跃功能isLive :&#x3D; make(chan bool)</code></pre><p>当用户发送完消息后，将true发送给该变量：</p><pre class="language-go" data-language="go"><code class="language-go">isLive &lt;- true &#x2F;&#x2F;用户的任意消息表示该用户活跃</code></pre><p>并且设置一个for循环和select用于判断该用户是否活跃，若不活跃则将用户断线：</p><pre class="language-go" data-language="go"><code class="language-go">for &#123;select &#123;case &lt;-isLive:&#x2F;&#x2F;当前用户活跃，重置计时器。case &lt;-time.After(10 * time.Second):user.SendMsg(&quot;你被踢了\n&quot;)close(user.C) &#x2F;&#x2F;关闭用于服务器给客户端发送消息的通道conn.Close() &#x2F;&#x2F;关闭客户端发送的链接return&#125;&#125;</code></pre><p>当isLive为true，则重置计时器。当超过一定时间，则关闭通道和链接。</p><h1 id="私聊功能"><a href="#私聊功能" class="headerlink" title="私聊功能"></a>私聊功能</h1><p>在上一节中增加了超时强踢功能，本节增加一个私聊功能，通过”to|用户名|消息内容”来判断用户是否想开启私聊。</p><p>首先通过strings.Split来提取要对话的对象，当不存在该对象时则返回对应的消息，否则提取对话内容，并通过SendMsg方法将对话内容发送给指定的用户：</p><pre class="language-go" data-language="go"><code class="language-go">if len(msg) &gt; 3 &amp;&amp; msg[:3] &#x3D;&#x3D; &quot;to|&quot; &#123;&#x2F;&#x2F;消息格式为：&quot;to|用户名|消息内容&quot;remoteName :&#x3D; strings.Split(msg, &quot;|&quot;)[1]&#x2F;&#x2F;判断格式是否正确if remoteName &#x3D;&#x3D; &quot;&quot; &#123;u.SendMsg(&quot;发送内容的格式有误，正确的格式为：to|用户名|消息内容\n&quot;)return&#125;&#x2F;&#x2F;判断是否有这个人remoteUser, ok :&#x3D; u.server.OnlineMap[remoteName]if !ok &#123;u.SendMsg(&quot;该用户名不存在\n&quot;)return&#125;content :&#x3D; strings.Split(msg, &quot;|&quot;)[2]if content &#x3D;&#x3D; &quot;&quot; &#123;u.SendMsg(&quot;无消息发送，请输入内容\n&quot;)return&#125;&#x2F;&#x2F;给目标用户发消息remoteUser.SendMsg(&quot;用户 &quot; + u.Name + &quot; 给您发消息：&quot; + content + &quot;\n&quot;)</code></pre><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>在上面几节中主要是对服务器的功能进行，现在定义一个客户端来发送这些请求。</p><p>首先是定义一个结构体Client，用于存放当前用户的相关信息，例如请求的服务器的地址、端口号、用户名、用户链接、菜单选项。</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;定义结构，封装功能type Client struct &#123;&#x2F;&#x2F;服务器的Ip地址和接口ServerIp   stringServerPort int&#x2F;&#x2F;用户名Name string&#x2F;&#x2F;链接conn net.Conn&#x2F;&#x2F;菜单选项flag int&#125;</code></pre><p>然后利用flag标志来利用命令行输入地址和端口号：</p><pre class="language-go" data-language="go"><code class="language-go">var serverIp stringvar serverPort int&#x2F;&#x2F;用于解析命令行的输入参数func init() &#123;&#x2F;&#x2F; -ip 127.0.0.1 -port 9090flag.StringVar(&amp;serverIp, &quot;ip&quot;, &quot;127.0.0.1&quot;, &quot;设置服务器IP地址(默认为127.0.0.1)&quot;)flag.IntVar(&amp;serverPort, &quot;port&quot;, 9090, &quot;设置服务器端口(默认为9090)&quot;)&#125;func main() &#123;&#x2F;&#x2F;解析参数flag.Parse()&#125;</code></pre><p>定义init函数来使得在主函数之前定义好地址和端口号。</p><p>然后是菜单选项，对服务器定义的一些功能进行封装，例如公聊、私聊、更新用户名等操作。</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;显示用户可选择的菜单func (c *Client) menu() bool &#123;var flag intfmt.Println(&quot;1.公聊模式&quot;)fmt.Println(&quot;2.私聊模式&quot;)fmt.Println(&quot;3.更新用户名&quot;)fmt.Println(&quot;0.退出&quot;)fmt.Scanln(&amp;flag)if flag &gt;&#x3D; 0 &amp;&amp; flag &lt;&#x3D; 3 &#123;&#x2F;&#x2F;根据用户选择的内容来作出对应的业务c.flag &#x3D; flagreturn true&#125; else &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;请输入合法范围内的数字&lt;&lt;&lt;&lt;&quot;)return false&#125;&#125;&#x2F;&#x2F;运行业务func (c *Client) Run() &#123;for c.flag !&#x3D; 0 &#123;&#x2F;&#x2F;判断flag是否在可选择的范围里for !c.menu() &#123;&#x2F;&#x2F;循环，直到返回true&#125;switch c.flag &#123;case 1:&#x2F;&#x2F;公聊模式c.PublicChat()case 2:&#x2F;&#x2F;私聊模式c.PrivateChat()case 3:&#x2F;&#x2F;更新用户名c.UpdateName()&#125;&#125;c.conn.Close()&#125;</code></pre><p>用户输入对应的序号时，开启对应的功能，若用户不想进行操作，则在按0之后关闭链接下线。</p><p>封装的功能如下：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;更新用户名func (c *Client) UpdateName() bool &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;请输入用户名&quot;)fmt.Scanln(&amp;c.Name) &#x2F;&#x2F;输入需要修改的名字sendName :&#x3D; &quot;rename|&quot; + c.Name + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendName)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write:&quot;, err)return false&#125;return true&#125;&#x2F;&#x2F;公聊模式func (c *Client) PublicChat() &#123;&#x2F;&#x2F;提示用户输入消息var chatMsg stringfmt.Println(&quot;请输入消息,exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#x2F;&#x2F;发给服务器for chatMsg !&#x3D; &quot;exit&quot; &#123;&#x2F;&#x2F;判断消息是否为空，不为空则发送消息if chatMsg !&#x3D; &quot;&quot; &#123;&#x2F;&#x2F;将消息写入链接中sendMsg :&#x3D; chatMsg + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)break&#125;&#125;&#x2F;&#x2F;继续写入消息fmt.Println(&quot;请输入消息,exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#125;&#125;&#x2F;&#x2F;查询列表中的用户func (c *Client) SelectUsers() &#123;sendMsg :&#x3D; &quot;who\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)return&#125;&#125;&#x2F;&#x2F;私聊模式func (c *Client) PrivateChat() &#123;&#x2F;&#x2F;定义查询的名字和自定义的内容var remoteName stringvar chatMsg string&#x2F;&#x2F;查询当前用户的列表c.SelectUsers()&#x2F;&#x2F;输入查询的名字fmt.Println(&quot;请输入对话的用户名称:&quot;)fmt.Scanln(&amp;remoteName)&#x2F;&#x2F;输入对话内容fmt.Println(&quot;请输入对话内容，exit退出&quot;)fmt.Scanln(&amp;chatMsg)for chatMsg !&#x3D; &quot;exit&quot; &#123;if len(chatMsg) !&#x3D; 0 &#123;sendMsg :&#x3D; &quot;to|&quot; + remoteName + &quot;|&quot; + chatMsg + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)break&#125;&#125;chatMsg &#x3D; &quot;&quot;fmt.Println(&quot;请输入对话内容，exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#125;&#125;</code></pre><p>为了能够读取服务器发送的消息，定义一个方法来接收：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;接收服务器的消息func (c *Client) DealResponse() &#123;&#x2F;&#x2F;一旦conn有数据，就直接copy到stdout标准输出上，永久阻塞监听if _, err :&#x3D; io.Copy(os.Stdout, c.conn); err !&#x3D; nil &#123;fmt.Println(&quot;链接已关闭&quot;)return&#125;&#125;</code></pre><p>io.Copy能够将链接中的消息发送给命令行，若没有消息则进行阻塞等待消息传入。</p><p>最后主函数定义对象并开启链接：</p><pre class="language-go" data-language="go"><code class="language-go">func main() &#123;&#x2F;&#x2F;解析参数flag.Parse()&#x2F;&#x2F;请求服务器client :&#x3D; NewClient(serverIp, serverPort)if client &#x3D;&#x3D; nil &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;&gt; 链接服务器失败...&quot;)return&#125;fmt.Println(&quot;链接服务器成功...&quot;)go client.Run()&#x2F;&#x2F;处理server的回执消息client.DealResponse()&#x2F;&#x2F;启动客户端的业务&#x2F;&#x2F; go mustCopy(client.conn, os.Stdin)&#x2F;&#x2F; mustCopy(os.Stdout, client.conn)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> go学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/16107.html"/>
      <url>/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
