<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式缓存GeeCache</title>
      <link href="/51338.html"/>
      <url>/51338.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存GeeCache"><a href="#分布式缓存GeeCache" class="headerlink" title="分布式缓存GeeCache"></a>分布式缓存GeeCache</h1><p>该文档是对<a href="https://geektutu.com/post/geecache.html">7天用Go从零实现分布式缓存GeeCache教程系列</a>的总结。</p><h2 id="Day1-LRU缓存淘汰策略"><a href="#Day1-LRU缓存淘汰策略" class="headerlink" title="Day1 LRU缓存淘汰策略"></a>Day1 LRU缓存淘汰策略</h2><p>假定缓存能够使用的内存为N，当某一时间点增加一条缓存记录时超过了N，这时就需要删除一些缓存来腾空位置。那么删除哪些缓存较为合适？这里有三种缓存淘汰策略：<code>FIFO(First In First Out)</code>，<code>LFU(Least Frequently Used)</code>和 <code>LRU(Least Recently Used)</code></p><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>顾名思义，先进来的缓存先被淘汰。这时就会出现一些问题，经常访问的数据会被频繁地添加进缓存，又被淘汰出去，导致缓存命中率降低。</p><h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>该策略认为，最少使用的缓存即为被淘汰的缓存。因此该策略需要维护一个按照访问次序排序的队列，当访问某条缓存时，该条缓存的访问次序加1，然后该队列重新排序。这样的问题就是需要维护该队列使得内存占用高，且该策略受限于历史缓存，即某条缓存以前访问量大而现在很少访问，但是它的访问次数还是很高，这就导致该条缓存迟迟不能被淘汰。</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>该策略认为最近最少使用的缓存应该被淘汰。这个策略是FIFO和LFU的结合体，既限制了时间又限制了访问次数，当最近一段时间某条缓存的访问量最少则被淘汰。算法的实现为建立一条队列，当访问某条缓存时就将该缓存移至最后，而最前的缓存则被淘汰。</p><h3 id="LRU实现"><a href="#LRU实现" class="headerlink" title="LRU实现"></a>LRU实现</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>LRU算法的主要数据结构由队列和字典组成。字典存储键和值的映射关系，作用为查询缓存；而队列有值组成，当访问某条缓存时该条缓存移动至末尾。如下图所示LRU算法的主要数据结构：</p><img src="https://geektutu.com/post/geecache-day1/lru.jpg" alt="implement lru algorithm with golang"  /><p>因此根据该图我们需要创建一个包括字典和队列的结构体Cache，以便增删改查。</p><p>结构体的定义如下所示：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;*定义缓存结构体，包括：最大内存maxBytes当前内存nbytes链表（队列）ll，利用标准库list实现字典cache删除操作OnEvicted，当删除某条内存时的一些操作*&#x2F;type Cache struct &#123;maxBytes int64                    &#x2F;&#x2F;最大缓存数nBytes   int64                    &#x2F;&#x2F;当前缓存数ll       *list.List               &#x2F;&#x2F;链表cache    map[string]*list.Element &#x2F;&#x2F;键值对，用于查询对应的值&#x2F;&#x2F;删除操作后的回调函数OnEvicted func(key string, value Value)&#125;</code></pre><p><code>list.Element</code>为链表中的元素，可从链表中获取。</p><p><code>list.Element</code>中的<code>Value</code>为空接口，可被结构体Entry所赋值，Entry里保存键和值：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;保存键值对type Entry struct &#123;key   stringvalue Value&#125;</code></pre><p><code>Value</code>为接口，其内为：</p><pre class="language-go" data-language="go"><code class="language-go">type Value interface &#123;Len() int &#x2F;&#x2F;计算值的大小&#125;</code></pre><p><code>Len()</code>函数用于计算数据值的大小。</p><p>初始化函数为：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;初始化func New(maxBytes int64, onEvicted func(key string, value Value)) *Cache &#123;return &amp;Cache&#123;maxBytes:  maxBytes,ll:        list.New(),cache:     make(map[string]*list.Element),OnEvicted: onEvicted,&#125;&#125;</code></pre><p>为了方便统计链表中元素的个数，为<em>Cache</em>结构体定义一个方法以便外部调用：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;定义Len方法，用于统计链表中元素的个数func (c *Cache) Len() int &#123;return c.ll.Len()&#125;</code></pre><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>1、增改操作被定义在一个函数中：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;增加&#x2F;修改记录操作func (c *Cache) Add(key string, value Value) &#123;&#x2F;&#x2F;当链表中有该记录，则进行刷新if ele, ok :&#x3D; c.cache[key]; ok &#123;&#x2F;&#x2F;将记录移至第一位c.ll.MoveToFront(ele)&#x2F;&#x2F;修改链表元素对应的Value&#x2F;&#x2F;Value为空接口，可用于接收Entry结构，结构中包含对应的键和value值kv :&#x3D; ele.Value.(*Entry) &#x2F;&#x2F;此操作为类型断言，并将&#x2F;&#x2F;修改内存c.nBytes +&#x3D; int64(value.Len()) - int64(kv.value.Len())&#x2F;&#x2F;修改字典中的值kv.value &#x3D; value&#125; else &#123;&#x2F;&#x2F;在链表中创建元素，并将元素推到第一位&#x2F;&#x2F;输入为元素值value，为空接口类型ele :&#x3D; c.ll.PushFront(&amp;Entry&#123;key, value&#125;)&#x2F;&#x2F;将元素存放至字典中c.cache[key] &#x3D; ele&#x2F;&#x2F;增加内存c.nBytes +&#x3D; int64(len(key)) + int64(value.Len())&#125;&#x2F;&#x2F;循环判断内存是否超过最大内存for c.maxBytes !&#x3D; 0 &amp;&amp; c.maxBytes &lt; c.nBytes &#123;c.RemoveOldest() &#x2F;&#x2F;处理最不常用的记录&#125;&#125;</code></pre><p>增改的思路为：</p><ul><li>判断链表中是否存在这个元素<ul><li>若存在，则将该元素移动至首位，并且更新使用内存和字典中键对应的值</li><li>若不存在，则在链表中创建一个元素，输入为<code>Entry</code>结构体对象，然后在字典中添加键和对应的值，增加使用内存。</li></ul></li><li>判断使用内存是否超过最大内存，超过则调用删除函数</li></ul><p>2、删除函数被定义为删除链表中末尾的元素（经常使用的元素会被调用到首位）：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;删除最旧的记录操作func (c *Cache) RemoveOldest() &#123;&#x2F;&#x2F;获取末尾的元素ele :&#x3D; c.ll.Back()if ele !&#x3D; nil &#123;&#x2F;&#x2F;从链表中删除元素c.ll.Remove(ele)&#x2F;&#x2F;从元素中获取对应的结构体值kv :&#x3D; ele.Value.(*Entry)&#x2F;&#x2F;从字典中删除对应的键值对delete(c.cache, kv.key)&#x2F;&#x2F;减少使用内存c.nBytes -&#x3D; int64(len(kv.key)) + int64(kv.value.Len())&#x2F;&#x2F;调用回调函数if c.OnEvicted !&#x3D; nil &#123;c.OnEvicted(kv.key, kv.value)&#125;&#125;&#125;</code></pre><p>3、通过键名来查询对应的值：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;查询操作func (c *Cache) Get(key string) (value Value, ok bool) &#123;&#x2F;&#x2F;调用字典查询对应的值if ele, ok :&#x3D; c.cache[key]; ok &#123;&#x2F;&#x2F;从Entry结构体中调取对应的值kv :&#x3D; ele.Value.(*Entry)return kv.value, true&#125;return&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>定义一个字符类型，其类型实现Len方法，该方法的作用为计算字符串的大小“</p><pre class="language-go" data-language="go"><code class="language-go">type String stringfunc (d String) Len() int &#123;return len(d)&#125;</code></pre><p>然后测试之前实现的增删改查操作：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 查询func TestGet(t *testing.T) &#123;lru :&#x3D; New(int64(0), nil)&#x2F;&#x2F;添加缓存lru.Add(&quot;key1&quot;, String(&quot;abcd&quot;))&#x2F;&#x2F;获取对应的信息if value, ok :&#x3D; lru.Get(&quot;key1&quot;); !ok || string(value.(String)) !&#x3D; &quot;abcd&quot; &#123;t.Fatalf(&quot;cache hit key1&#x3D;1234 failed&quot;)&#125;if _, ok :&#x3D; lru.Get(&quot;key2&quot;); !ok &#123;t.Fatalf(&quot;cache miss key2 failed&quot;)&#125;&#125;</code></pre><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 删除func TestRemoveOldest(t *testing.T) &#123;k1, k2, k3 :&#x3D; &quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;v1, v2, v3 :&#x3D; &quot;value1&quot;, &quot;value2&quot;, &quot;v3&quot;caps :&#x3D; len(k1 + v1 + k2 + v2)lru :&#x3D; New(int64(caps), nil)lru.Add(k1, String(v1))lru.Add(k2, String(v2))lru.Add(k3, String(v3)) &#x2F;&#x2F;测试当超过容量后是否会移除旧的信息if _, ok :&#x3D; lru.Get(k1); ok || lru.Len() !&#x3D; 2 &#123;t.Fatal(&quot;Removeoldest key1 failed&quot;)&#125;&#125;</code></pre><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 回调函数func TestOnEvicted(t *testing.T) &#123;keys :&#x3D; make([]string, 0)callback :&#x3D; func(key string, value Value) &#123;keys &#x3D; append(keys, key)&#125;lru :&#x3D; New(int64(10), callback)lru.Add(&quot;key1&quot;, String(&quot;123456&quot;))lru.Add(&quot;k2&quot;, String(&quot;k2&quot;))lru.Add(&quot;k3&quot;, String(&quot;k3&quot;))lru.Add(&quot;k4&quot;, String(&quot;k4&quot;))expect :&#x3D; []string&#123;&quot;key1&quot;, &quot;k2&quot;&#125;if !reflect.DeepEqual(expect, keys) &#123;t.Fatalf(&quot;Call OnEvicted failed, expect keys equals to %s&quot;, expect)&#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> go学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通讯即时系统</title>
      <link href="/8862.html"/>
      <url>/8862.html</url>
      
        <content type="html"><![CDATA[<p>本文是对<a href="https://www.bilibili.com/video/BV1gf4y1r79E?p=37&vd_source=ee53bed98445adb36a8ecd71465f6240">8小时转职Golang工程师(如果你想低成本学习Go语言)_哔哩哔哩_bilibili</a>里的即时通信系统demo进行总结。</p><h1 id="基础server构建"><a href="#基础server构建" class="headerlink" title="基础server构建"></a>基础server构建</h1><p>本节主要是建立链接。</p><p>通过<code>net.listen</code>来监听端口，通过<code>Listener.Accept()</code>来接收客户端的请求，然后利用go来进行处理多个请求链接。</p><pre class="language-go" data-language="go"><code class="language-go">type Server struct &#123;Ip   stringPort int&#125;&#x2F;&#x2F;初始化func NewServer(ip string, port int) *Server &#123;return &amp;Server&#123;Ip:   ip,Port: port,&#125;&#125;func (s *Server) Handler(conn net.Conn) &#123;fmt.Println(&quot;链接建立成功&quot;)&#125;&#x2F;&#x2F;启动服务器的接口func (s *Server) Start() &#123;&#x2F;&#x2F;端口监听Listener, err :&#x3D; net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, s.Ip, s.Port))if err !&#x3D; nil &#123;fmt.Println(&quot;net.Listen err:&quot;, err)return&#125;&#x2F;&#x2F;关闭端口defer Listener.Close()for &#123;&#x2F;&#x2F;接收客户端的连接conn, err :&#x3D; Listener.Accept()if err !&#x3D; nil &#123;fmt.Println(&quot;Listener err:&quot;, err)return&#125;&#x2F;&#x2F; do handlergo s.Handler(conn)&#125;&#125;</code></pre><p>最后开启端口：</p><pre class="language-go" data-language="go"><code class="language-go">func main() &#123;server :&#x3D; NewServer(&quot;127.0.0.1&quot;, 8888)server.Start() &#x2F;&#x2F;开启端口&#125;</code></pre><p>当客户端发送请求链接时，服务器输出<code>链接建立成功</code>.</p><h1 id="用户上线功能"><a href="#用户上线功能" class="headerlink" title="用户上线功能"></a>用户上线功能</h1><p>在上一节中，建立了服务器与客户端的连接。在这一节中，添加用户并且服务器给客户端返回消息。</p><p>首先创建用户结构，用于存放用户名字、用户地址、用户通道、用户对应的链接。</p><pre class="language-go" data-language="go"><code class="language-go">type User struct &#123;Name stringAddr stringC    chan string &#x2F;&#x2F;用户通道，用于将消息传给用户conn net.Conn    &#x2F;&#x2F;用户链接&#125;</code></pre><p>C通道用于广播消息给所有客户端，而conn链接用于对该客户端的一些操作。</p><p>然后进行初始化：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;创建一个用户的APIfunc NewUser(conn net.Conn, server *Server) *User &#123;userAddr :&#x3D; conn.RemoteAddr().String() &#x2F;&#x2F;客户端的请求地址user :&#x3D; &amp;User&#123;Name:   userAddr,Addr:   userAddr,C:      make(chan string),conn:   conn,&#125;&#x2F;&#x2F;启动监听当前user channel消息的goroutinego user.ListenMessage()return user&#125;</code></pre><p>ListenMessage用于一直监听当前通道的消息，并将消息发送给给客户端:</p><pre class="language-go" data-language="go"><code class="language-go">func (u *User) ListenMessage() &#123;for &#123;msg :&#x3D; &lt;-u.Cu.conn.Write([]byte(msg + &quot;\n&quot;))&#125;&#125;</code></pre><p>在服务器的结构上，添加用户列表功能和消息功能，用户列表用于存放当前存在的用户，而消息功能用于将消息传递给客户端：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;创建用户列表OnlineMap map[string]*UsermapLock   sync.RWMutex&#x2F;&#x2F;消息广播的channelMessage chan string</code></pre><p>mapLock代表锁，用于当前用户的操作。</p><p>然后在handler里添加用户上线功能，并将用户添加至列表中，用于是并发运行该函数，因此加上锁来防止其他用户一起上线：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中s.mapLock.Lock() &#x2F;&#x2F;上锁s.OnlineMap[user.Name] &#x3D; users.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息s.BroadCase(user, &quot;已上线&quot;)&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#125;</code></pre><p>BroadCase用于广播消息，将消息通过用户通道来传递给用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;广播消息func (s *Server) BroadCase(user *User, msg string) &#123;sendMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + msgs.Message &lt;- sendMsg&#125;</code></pre><p>且在start方法中开启一个go程来持续监听消息通道，并将通道的消息传递给用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;监听消息广播通道，一旦有消息则将消息广播给所有用户func (s *Server) ListenMessage() &#123;for &#123;msg :&#x3D; &lt;-s.Message &#x2F;&#x2F; 无消息则阻塞s.mapLock.Lock()   &#x2F;&#x2F;上锁for _, user :&#x3D; range s.OnlineMap &#123;user.C &lt;- msg &#x2F;&#x2F;将消息传给所有用户&#125;s.mapLock.Unlock()&#125;&#125;</code></pre><h1 id="用户消息广播机制"><a href="#用户消息广播机制" class="headerlink" title="用户消息广播机制"></a>用户消息广播机制</h1><p>在上一节中已经实现了通过通道来将消息传递给每个客户端，本节主要是服务器读取客户端发来的消息并将消息进行广播，核心方法还是BroadCase：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中s.mapLock.Lock() &#x2F;&#x2F;上锁s.OnlineMap[user.Name] &#x3D; users.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息s.BroadCase(user, &quot;已上线&quot;)&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#x2F;&#x2F;接收客户端发送的消息并广播给所有用户go func() &#123;buf :&#x3D; make([]byte, 4096)for &#123;n, err :&#x3D; conn.Read(buf)if n &#x3D;&#x3D; 0 &#123;s.BroadCase(user, &quot;已下线&quot;)return&#125;if err !&#x3D; nil &amp;&amp; err !&#x3D; io.EOF &#123;fmt.Println(&quot;Conn Read err:&quot;, err)&#125;msg :&#x3D; string(buf[:n-1])s.BroadCase(user, msg)&#125;&#125;()&#125;</code></pre><p>在handler方法中增加一个go程来接收用户发来的消息，利用go程可以保持客户端与服务器互通。在go程中首先创建一个字节数组用于保存链接中的信息，并返回信息的长度，如果长度为0则表示用户断开了连接，因此给其他用户广播该用户已下线并结束这一个go程，如果长度不为0则将消息广播给所有用户，n-1表示信息里面最后一位是换行字符<code>\n</code>。</p><h1 id="用户业务层封装"><a href="#用户业务层封装" class="headerlink" title="用户业务层封装"></a>用户业务层封装</h1><p>在上一节中，在handler中定义了用户上线和下线以及将用户发送的消息进行广播，为了方便后续增加功能，现将这些功能进行封装给用户。</p><p>首先为user结构添加server对象：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;新增Server关联server *Server</code></pre><p>增加的意义在于user的方法可以调用server的方法，例如消息传递功能BroadCase。</p><p>定义上线功能，功能里包含用户列表增加新用户、广播用户上线：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户上线func (u *User) Online() &#123;&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中u.server.mapLock.Lock() &#x2F;&#x2F;上锁u.server.OnlineMap[u.Name] &#x3D; uu.server.mapLock.Unlock()&#x2F;&#x2F;广播当前用户上线消息u.server.BroadCase(u, &quot;已上线&quot;)&#125;</code></pre><p>同理定义下线功能：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户下线func (u *User) Offline() &#123;u.server.mapLock.Lock() &#x2F;&#x2F;上锁delete(u.server.OnlineMap, u.Name)u.server.mapLock.Unlock()u.server.BroadCase(u, &quot;已下线&quot;)&#125;</code></pre><p>定义发送消息功能，将客户端发送给服务器的消息进行封装：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户处理消息的业务func (u *User) DoMessage(msg string) &#123;u.server.BroadCase(u, msg)&#125;</code></pre><p>最后handler改为：</p><pre class="language-go" data-language="go"><code class="language-go">func (s *Server) Handler(conn net.Conn) &#123;&#x2F;&#x2F; fmt.Println(&quot;链接建立成功&quot;)user :&#x3D; NewUser(conn, s)&#x2F;&#x2F;用户上线，将用户加入到OnlineMap中user.Online()&#x2F;&#x2F;当前handler阻塞&#x2F;&#x2F; select&#123;&#125;&#x2F;&#x2F;接收客户端发送的消息并广播给所有用户go func() &#123;buf :&#x3D; make([]byte, 4096)for &#123;&#x2F;&#x2F;读取客户端传来的数据n, err :&#x3D; conn.Read(buf)if n &#x3D;&#x3D; 0 &#123;user.Offline() &#x2F;&#x2F;下线return&#125;if err !&#x3D; nil &amp;&amp; err !&#x3D; io.EOF &#123;fmt.Println(&quot;Conn Read err:&quot;, err)&#125;msg :&#x3D; string(buf[:n-1])user.DoMessage(msg) &#x2F;&#x2F;用户针对msg进行消息处理&#125;&#125;()&#125;</code></pre><h1 id="在线用户查询"><a href="#在线用户查询" class="headerlink" title="在线用户查询"></a>在线用户查询</h1><p>在上一节中定义消息处理函数DoMessage，现在在方法里增加用户查询功能，当用户输入<code>who</code>时，服务器返回用户在线列表：</p><pre class="language-go" data-language="go"><code class="language-go">func (u *User) DoMessage(msg string) &#123;if msg &#x3D;&#x3D; &quot;who&quot; &#123;&#x2F;&#x2F;查询当前在线用户都有哪些fmt.Println(&quot;进入该代码块&quot;)u.server.mapLock.Lock()for _, user :&#x3D; range u.server.OnlineMap &#123;onlineMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + &quot;在线...\n&quot;u.SendMsg(onlineMsg)&#125;u.server.mapLock.Unlock()&#125; else &#123;u.server.BroadCase(u, msg)&#125;&#125;</code></pre><p>当输入<code>who</code>时，遍历列表中的用户并将这些用户发送给请求的客户端，SendMsg方法用于将信息发送给当前用户：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;给当前User对应的客户端发送消息func (u *User) SendMsg(msg string) &#123;u.conn.Write([]byte(msg))&#125;</code></pre><p>由于消息里存在换行符等制表符，因此调用strings.TrimSpace将主要字符的左右两端的制表符和空格进行去除：</p><pre class="language-go" data-language="go"><code class="language-go">strings.TrimSpace(s string)</code></pre><h1 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h1><p>在上一节中，定义了查询在线用户功能。在本节中通过增加修改用户名的功能来为客户端发送的修改用户名请求进行处理，消息格式定义为：<code>rename|张三</code>：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户处理消息的业务func (u *User) DoMessage(msg string) &#123;if msg &#x3D;&#x3D; &quot;who&quot; &#123;&#x2F;&#x2F;查询当前在线用户都有哪些&#x2F;&#x2F; fmt.Println(&quot;进入该代码块&quot;)u.server.mapLock.Lock()for _, user :&#x3D; range u.server.OnlineMap &#123;onlineMsg :&#x3D; &quot;[&quot; + user.Addr + &quot;]&quot; + user.Name + &quot;:&quot; + &quot;在线...\n&quot;u.SendMsg(onlineMsg)&#125;u.server.mapLock.Unlock()&#125; else if len(msg) &gt; 7 &amp;&amp; msg[:7] &#x3D;&#x3D; &quot;rename|&quot; &#123;&#x2F;&#x2F;消息格式为：&quot;rename|张三&quot;&#x2F;&#x2F;将名字进行分离出来newName :&#x3D; strings.Split(msg, &quot;|&quot;)[1]if _, ok :&#x3D; u.server.OnlineMap[newName]; ok &#123;u.SendMsg(&quot;当前用户名已被注册\n&quot;)&#125; else &#123;u.server.mapLock.Lock()&#x2F;&#x2F;删除旧的用户delete(u.server.OnlineMap, u.Name)u.server.OnlineMap[newName] &#x3D; u &#x2F;&#x2F;将新的名字添加至用户列表中u.server.mapLock.Unlock()u.Name &#x3D; newNameu.SendMsg(&quot;您已经更新用户名：&quot; + u.Name + &quot;\n&quot;)&#125;&#125; else &#123;u.server.BroadCase(u, msg)&#125;&#125;</code></pre><p>通过strings.Split将消息中的请求名字给提取出来，并且判断该名字是否已被注册，若被注册就给该客户端发消息：<code>当前用户名已被注册\n</code>，否则先删除列表中旧的用户，更新新的用户名，更新完成后给该客户端发送更新后的信息。</p><h1 id="超时强踢功能"><a href="#超时强踢功能" class="headerlink" title="超时强踢功能"></a>超时强踢功能</h1><p>在上一节中，对用户名进行了修改。在本节中加入超时强踢功能，当客户端在一定时间内没有发送消息就默认掉线，服务器就关闭对该客户端的链接：</p><p>添加一个bool通道，用于判断该用户是否活跃：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;用户活跃功能isLive :&#x3D; make(chan bool)</code></pre><p>当用户发送完消息后，将true发送给该变量：</p><pre class="language-go" data-language="go"><code class="language-go">isLive &lt;- true &#x2F;&#x2F;用户的任意消息表示该用户活跃</code></pre><p>并且设置一个for循环和select用于判断该用户是否活跃，若不活跃则将用户断线：</p><pre class="language-go" data-language="go"><code class="language-go">for &#123;select &#123;case &lt;-isLive:&#x2F;&#x2F;当前用户活跃，重置计时器。case &lt;-time.After(10 * time.Second):user.SendMsg(&quot;你被踢了\n&quot;)close(user.C) &#x2F;&#x2F;关闭用于服务器给客户端发送消息的通道conn.Close() &#x2F;&#x2F;关闭客户端发送的链接return&#125;&#125;</code></pre><p>当isLive为true，则重置计时器。当超过一定时间，则关闭通道和链接。</p><h1 id="私聊功能"><a href="#私聊功能" class="headerlink" title="私聊功能"></a>私聊功能</h1><p>在上一节中增加了超时强踢功能，本节增加一个私聊功能，通过”to|用户名|消息内容”来判断用户是否想开启私聊。</p><p>首先通过strings.Split来提取要对话的对象，当不存在该对象时则返回对应的消息，否则提取对话内容，并通过SendMsg方法将对话内容发送给指定的用户：</p><pre class="language-go" data-language="go"><code class="language-go">if len(msg) &gt; 3 &amp;&amp; msg[:3] &#x3D;&#x3D; &quot;to|&quot; &#123;&#x2F;&#x2F;消息格式为：&quot;to|用户名|消息内容&quot;remoteName :&#x3D; strings.Split(msg, &quot;|&quot;)[1]&#x2F;&#x2F;判断格式是否正确if remoteName &#x3D;&#x3D; &quot;&quot; &#123;u.SendMsg(&quot;发送内容的格式有误，正确的格式为：to|用户名|消息内容\n&quot;)return&#125;&#x2F;&#x2F;判断是否有这个人remoteUser, ok :&#x3D; u.server.OnlineMap[remoteName]if !ok &#123;u.SendMsg(&quot;该用户名不存在\n&quot;)return&#125;content :&#x3D; strings.Split(msg, &quot;|&quot;)[2]if content &#x3D;&#x3D; &quot;&quot; &#123;u.SendMsg(&quot;无消息发送，请输入内容\n&quot;)return&#125;&#x2F;&#x2F;给目标用户发消息remoteUser.SendMsg(&quot;用户 &quot; + u.Name + &quot; 给您发消息：&quot; + content + &quot;\n&quot;)</code></pre><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>在上面几节中主要是对服务器的功能进行，现在定义一个客户端来发送这些请求。</p><p>首先是定义一个结构体Client，用于存放当前用户的相关信息，例如请求的服务器的地址、端口号、用户名、用户链接、菜单选项。</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;定义结构，封装功能type Client struct &#123;&#x2F;&#x2F;服务器的Ip地址和接口ServerIp   stringServerPort int&#x2F;&#x2F;用户名Name string&#x2F;&#x2F;链接conn net.Conn&#x2F;&#x2F;菜单选项flag int&#125;</code></pre><p>然后利用flag标志来利用命令行输入地址和端口号：</p><pre class="language-go" data-language="go"><code class="language-go">var serverIp stringvar serverPort int&#x2F;&#x2F;用于解析命令行的输入参数func init() &#123;&#x2F;&#x2F; -ip 127.0.0.1 -port 9090flag.StringVar(&amp;serverIp, &quot;ip&quot;, &quot;127.0.0.1&quot;, &quot;设置服务器IP地址(默认为127.0.0.1)&quot;)flag.IntVar(&amp;serverPort, &quot;port&quot;, 9090, &quot;设置服务器端口(默认为9090)&quot;)&#125;func main() &#123;&#x2F;&#x2F;解析参数flag.Parse()&#125;</code></pre><p>定义init函数来使得在主函数之前定义好地址和端口号。</p><p>然后是菜单选项，对服务器定义的一些功能进行封装，例如公聊、私聊、更新用户名等操作。</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;显示用户可选择的菜单func (c *Client) menu() bool &#123;var flag intfmt.Println(&quot;1.公聊模式&quot;)fmt.Println(&quot;2.私聊模式&quot;)fmt.Println(&quot;3.更新用户名&quot;)fmt.Println(&quot;0.退出&quot;)fmt.Scanln(&amp;flag)if flag &gt;&#x3D; 0 &amp;&amp; flag &lt;&#x3D; 3 &#123;&#x2F;&#x2F;根据用户选择的内容来作出对应的业务c.flag &#x3D; flagreturn true&#125; else &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;请输入合法范围内的数字&lt;&lt;&lt;&lt;&quot;)return false&#125;&#125;&#x2F;&#x2F;运行业务func (c *Client) Run() &#123;for c.flag !&#x3D; 0 &#123;&#x2F;&#x2F;判断flag是否在可选择的范围里for !c.menu() &#123;&#x2F;&#x2F;循环，直到返回true&#125;switch c.flag &#123;case 1:&#x2F;&#x2F;公聊模式c.PublicChat()case 2:&#x2F;&#x2F;私聊模式c.PrivateChat()case 3:&#x2F;&#x2F;更新用户名c.UpdateName()&#125;&#125;c.conn.Close()&#125;</code></pre><p>用户输入对应的序号时，开启对应的功能，若用户不想进行操作，则在按0之后关闭链接下线。</p><p>封装的功能如下：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;更新用户名func (c *Client) UpdateName() bool &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;请输入用户名&quot;)fmt.Scanln(&amp;c.Name) &#x2F;&#x2F;输入需要修改的名字sendName :&#x3D; &quot;rename|&quot; + c.Name + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendName)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write:&quot;, err)return false&#125;return true&#125;&#x2F;&#x2F;公聊模式func (c *Client) PublicChat() &#123;&#x2F;&#x2F;提示用户输入消息var chatMsg stringfmt.Println(&quot;请输入消息,exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#x2F;&#x2F;发给服务器for chatMsg !&#x3D; &quot;exit&quot; &#123;&#x2F;&#x2F;判断消息是否为空，不为空则发送消息if chatMsg !&#x3D; &quot;&quot; &#123;&#x2F;&#x2F;将消息写入链接中sendMsg :&#x3D; chatMsg + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)break&#125;&#125;&#x2F;&#x2F;继续写入消息fmt.Println(&quot;请输入消息,exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#125;&#125;&#x2F;&#x2F;查询列表中的用户func (c *Client) SelectUsers() &#123;sendMsg :&#x3D; &quot;who\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)return&#125;&#125;&#x2F;&#x2F;私聊模式func (c *Client) PrivateChat() &#123;&#x2F;&#x2F;定义查询的名字和自定义的内容var remoteName stringvar chatMsg string&#x2F;&#x2F;查询当前用户的列表c.SelectUsers()&#x2F;&#x2F;输入查询的名字fmt.Println(&quot;请输入对话的用户名称:&quot;)fmt.Scanln(&amp;remoteName)&#x2F;&#x2F;输入对话内容fmt.Println(&quot;请输入对话内容，exit退出&quot;)fmt.Scanln(&amp;chatMsg)for chatMsg !&#x3D; &quot;exit&quot; &#123;if len(chatMsg) !&#x3D; 0 &#123;sendMsg :&#x3D; &quot;to|&quot; + remoteName + &quot;|&quot; + chatMsg + &quot;\n&quot;if _, err :&#x3D; c.conn.Write([]byte(sendMsg)); err !&#x3D; nil &#123;fmt.Println(&quot;conn write err:&quot;, err)break&#125;&#125;chatMsg &#x3D; &quot;&quot;fmt.Println(&quot;请输入对话内容，exit退出&quot;)fmt.Scanln(&amp;chatMsg)&#125;&#125;</code></pre><p>为了能够读取服务器发送的消息，定义一个方法来接收：</p><pre class="language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;接收服务器的消息func (c *Client) DealResponse() &#123;&#x2F;&#x2F;一旦conn有数据，就直接copy到stdout标准输出上，永久阻塞监听if _, err :&#x3D; io.Copy(os.Stdout, c.conn); err !&#x3D; nil &#123;fmt.Println(&quot;链接已关闭&quot;)return&#125;&#125;</code></pre><p>io.Copy能够将链接中的消息发送给命令行，若没有消息则进行阻塞等待消息传入。</p><p>最后主函数定义对象并开启链接：</p><pre class="language-go" data-language="go"><code class="language-go">func main() &#123;&#x2F;&#x2F;解析参数flag.Parse()&#x2F;&#x2F;请求服务器client :&#x3D; NewClient(serverIp, serverPort)if client &#x3D;&#x3D; nil &#123;fmt.Println(&quot;&gt;&gt;&gt;&gt;&gt; 链接服务器失败...&quot;)return&#125;fmt.Println(&quot;链接服务器成功...&quot;)go client.Run()&#x2F;&#x2F;处理server的回执消息client.DealResponse()&#x2F;&#x2F;启动客户端的业务&#x2F;&#x2F; go mustCopy(client.conn, os.Stdin)&#x2F;&#x2F; mustCopy(os.Stdout, client.conn)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> go学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/16107.html"/>
      <url>/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
